<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>

<title>Telegram Mini App ‚Äì Digital Pixel World</title>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    touch-action: none;
  }

  body {
    background: #0b0f14;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  /* Telegram top safe area */
  #safe-top {
    height: 24px;
    width: 100%;
    background: #0b0f14;
  }

  /* App container */
  #app {
    width: 100%;
    height: calc(100vh - 24px);
    position: relative;
  }

  #ui {
    position: absolute;
    top: 12px;
    left: 12px;
    color: #ffffff;
    font-size: 12px;
    opacity: 0.85;
    z-index: 10;
    pointer-events: none;
  }

  canvas {
    display: block;
  }
</style>
</head>

<body>

<div id="safe-top"></div>

<div id="app">
  <div id="ui">
    üåç Digital World<br>
    Each voxel = 1 land
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* =========================
   SCENE
========================= */
const app = document.getElementById("app");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

const camera = new THREE.PerspectiveCamera(
  65,
  app.clientWidth / app.clientHeight,
  0.1,
  500
);
camera.position.set(40, 70, 100);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  powerPreference: "high-performance"
});
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
app.appendChild(renderer.domElement);

/* =========================
   CONTROLS (MOBILE)
========================= */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.enablePan = false;
controls.minDistance = 30;
controls.maxDistance = 160;
controls.maxPolarAngle = Math.PI / 2.05;

/* =========================
   LIGHT
========================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.45));

const sun = new THREE.DirectionalLight(0xffffff, 0.85);
sun.position.set(120, 200, 80);
scene.add(sun);

/* =========================
   WORLD CONFIG
========================= */
const WORLD_SIZE = 36;
const MAX_HEIGHT = 10;
const VOXEL = 1;

const geometry = new THREE.BoxGeometry(VOXEL, VOXEL, VOXEL);

/* zoning / land class */
function materialByHeight(y) {
  if (y >= 7) return new THREE.MeshStandardMaterial({ color: 0xffc857 });
  if (y >= 4) return new THREE.MeshStandardMaterial({ color: 0x4caf50 });
  return new THREE.MeshStandardMaterial({ color: 0x546e7a });
}

/* simple procedural noise */
function noise(x, z) {
  return (
    Math.sin(x * 0.28) +
    Math.cos(z * 0.28) +
    Math.sin((x + z) * 0.18)
  );
}

/* =========================
   GENERATE WORLD
========================= */
for (let x = -WORLD_SIZE / 2; x < WORLD_SIZE / 2; x++) {
  for (let z = -WORLD_SIZE / 2; z < WORLD_SIZE / 2; z++) {

    const h = Math.floor(
      (noise(x, z) + 2) * 0.45 * MAX_HEIGHT
    );

    for (let y = 0; y < h; y++) {
      const voxel = new THREE.Mesh(
        geometry,
        materialByHeight(y)
      );
      voxel.position.set(x, y, z);
      scene.add(voxel);
    }
  }
}

/* =========================
   RENDER LOOP
========================= */
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

/* =========================
   RESIZE (ORIENTATION SAFE)
========================= */
window.addEventListener("resize", () => {
  const w = app.clientWidth;
  const h = app.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>

</body>
</html>